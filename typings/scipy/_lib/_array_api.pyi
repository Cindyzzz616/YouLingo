"""
This type stub file was generated by pyright.
"""

import dataclasses
import numpy.typing as npt
from collections.abc import Generator
from contextlib import contextmanager
from contextvars import ContextVar
from types import ModuleType
from typing import Any, TypeAlias

"""Utility functions to use Python Array API compatible libraries.

For the context about the Array API see:
https://data-apis.org/array-api/latest/purpose_and_scope.html

The SciPy use case of the Array API is described on the following page:
https://data-apis.org/array-api/latest/use_cases.html#use-case-scipy
"""
__all__ = ['_asarray', 'array_namespace', 'assert_almost_equal', 'assert_array_almost_equal', 'default_xp', 'eager_warns', 'is_lazy_array', 'is_marray', 'is_array_api_strict', 'is_complex', 'is_cupy', 'is_jax', 'is_numpy', 'is_torch', 'SCIPY_ARRAY_API', 'SCIPY_DEVICE', 'scipy_namespace_for', 'xp_assert_close', 'xp_assert_equal', 'xp_assert_less', 'xp_copy', 'xp_device', 'xp_ravel', 'xp_size', 'xp_unsupported_param_msg', 'xp_vector_norm', 'xp_capabilities', 'xp_result_type', 'xp_promote']
SCIPY_ARRAY_API: str | bool = ...
SCIPY_DEVICE = ...
_GLOBAL_CONFIG = ...
Array: TypeAlias = Any
ArrayLike: TypeAlias = Array | npt.ArrayLike
def array_namespace(*arrays: Array) -> ModuleType:
    """Get the array API compatible namespace for the arrays xs.

    Parameters
    ----------
    *arrays : sequence of array_like
        Arrays used to infer the common namespace.

    Returns
    -------
    namespace : module
        Common namespace.

    Notes
    -----
    Thin wrapper around `array_api_compat.array_namespace`.

    1. Check for the global switch: SCIPY_ARRAY_API. This can also be accessed
       dynamically through ``_GLOBAL_CONFIG['SCIPY_ARRAY_API']``.
    2. `_compliance_scipy` raise exceptions on known-bad subclasses. See
       its definition for more details.

    When the global switch is False, it defaults to the `numpy` namespace.
    In that case, there is no compliance check. This is a convenience to
    ease the adoption. Otherwise, arrays must comply with the new rules.
    """
    ...

def xp_copy(x: Array, *, xp: ModuleType | None = ...) -> Array:
    """
    Copies an array.

    Parameters
    ----------
    x : array

    xp : array_namespace

    Returns
    -------
    copy : array
        Copied array

    Notes
    -----
    This copy function does not offer all the semantics of `np.copy`, i.e. the
    `subok` and `order` keywords are not used.
    """
    ...

_default_xp_ctxvar: ContextVar[ModuleType] = ...
@contextmanager
def default_xp(xp: ModuleType) -> Generator[None, None, None]:
    """In all ``xp_assert_*`` and ``assert_*`` function calls executed within this
    context manager, test by default that the array namespace is
    the provided across all arrays, unless one explicitly passes the ``xp=``
    parameter or ``check_namespace=False``.

    Without this context manager, the default value for `xp` is the namespace
    for the desired array (the second parameter of the tests).
    """
    ...

def eager_warns(x, warning_type, match=...): # -> nullcontext[None]:
    """pytest.warns context manager, but only if x is not a lazy array."""
    ...

def xp_assert_equal(actual, desired, *, check_namespace=..., check_dtype=..., check_shape=..., check_0d=..., err_msg=..., xp=...): # -> Any | None:
    ...

def xp_assert_close(actual, desired, *, rtol=..., atol=..., check_namespace=..., check_dtype=..., check_shape=..., check_0d=..., err_msg=..., xp=...): # -> Any | None:
    ...

def xp_assert_less(actual, desired, *, check_namespace=..., check_dtype=..., check_shape=..., check_0d=..., err_msg=..., verbose=..., xp=...): # -> Any | None:
    ...

def assert_array_almost_equal(actual, desired, decimal=..., *args, **kwds): # -> Any | None:
    """Backwards compatible replacement. In new code, use xp_assert_close instead.
    """
    ...

def assert_almost_equal(actual, desired, decimal=..., *args, **kwds): # -> Any | None:
    """Backwards compatible replacement. In new code, use xp_assert_close instead.
    """
    ...

def xp_unsupported_param_msg(param: Any) -> str:
    ...

def is_complex(x: Array, xp: ModuleType) -> bool:
    ...

def scipy_namespace_for(xp: ModuleType) -> ModuleType | None:
    """Return the `scipy`-like namespace of a non-NumPy backend

    That is, return the namespace corresponding with backend `xp` that contains
    `scipy` sub-namespaces like `linalg` and `special`. If no such namespace
    exists, return ``None``. Useful for dispatching.
    """
    ...

def xp_vector_norm(x: Array, /, *, axis: int | tuple[int] | None = ..., keepdims: bool = ..., ord: int | float = ..., xp: ModuleType | None = ...) -> Array:
    ...

def xp_ravel(x: Array, /, *, xp: ModuleType | None = ...) -> Array:
    ...

def xp_swapaxes(a, axis1, axis2, xp=...): # -> Any:
    ...

def xp_result_type(*args, force_floating=..., xp):
    """
    Returns the dtype that results from applying type promotion rules
    (see Array API Standard Type Promotion Rules) to the arguments. Augments
    standard `result_type` in a few ways:

    - There is a `force_floating` argument that ensures that the result type
      is floating point, even when all args are integer.
    - When a TypeError is raised (e.g. due to an unsupported promotion)
      and `force_floating=True`, we define a custom rule: use the result type
      of the default float and any other floats passed. See
      https://github.com/scipy/scipy/pull/22695/files#r1997905891
      for rationale.
    - This function accepts array-like iterables, which are immediately converted
      to the namespace's arrays before result type calculation. Consequently, the
      result dtype may be different when an argument is `1.` vs `[1.]`.

    Typically, this function will be called shortly after `array_namespace`
    on a subset of the arguments passed to `array_namespace`.
    """
    ...

def xp_promote(*args, broadcast=..., force_floating=..., xp): # -> Array | tuple[Array | Any, ...] | tuple[Any, ...]:
    """
    Promotes elements of *args to result dtype, ignoring `None`s.
    Includes options for forcing promotion to floating point and
    broadcasting the arrays, again ignoring `None`s.
    Type promotion rules follow `xp_result_type` instead of `xp.result_type`.

    Typically, this function will be called shortly after `array_namespace`
    on a subset of the arguments passed to `array_namespace`.

    This function accepts array-like iterables, which are immediately converted
    to the namespace's arrays before result type calculation. Consequently, the
    result dtype may be different when an argument is `1.` vs `[1.]`.

    See Also
    --------
    xp_result_type
    """
    ...

def xp_float_to_complex(arr: Array, xp: ModuleType | None = ...) -> Array:
    ...

def xp_default_dtype(xp):
    """Query the namespace-dependent default floating-point dtype.
    """
    ...

def xp_result_device(*args): # -> Device | None:
    """Return the device of an array in `args`, for the purpose of
    input-output device propagation.
    If there are multiple devices, return an arbitrary one.
    If there are no arrays, return None (this typically happens only on NumPy).
    """
    ...

def is_marray(xp): # -> bool:
    """Returns True if `xp` is an MArray namespace; False otherwise."""
    ...

@dataclasses.dataclass(repr=False)
class _XPSphinxCapability:
    cpu: bool | None
    gpu: bool | None
    warnings: list[str] = ...
    def __str__(self) -> str:
        ...
    


def xp_capabilities(*, capabilities_table=..., skip_backends=..., xfail_backends=..., cpu_only=..., np_only=..., reason=..., exceptions=..., warnings=..., allow_dask_compute=..., jax_jit=...): # -> Callable[..., Any]:
    """Decorator for a function that states its support among various
    Array API compatible backends.

    This decorator has two effects:
    1. It allows tagging tests with ``@make_xp_test_case`` or
       ``make_xp_pytest_param`` (see below) to automatically generate
       SKIP/XFAIL markers and perform additional backend-specific
       testing, such as extra validation for Dask and JAX;
    2. It automatically adds a note to the function's docstring, containing
       a table matching what has been tested.    

    See Also
    --------
    make_xp_test_case
    make_xp_pytest_param
    array_api_extra.testing.lazy_xp_function
    """
    ...

def make_xp_test_case(*funcs, capabilities_table=...): # -> Callable[..., Any]:
    ...

def make_xp_pytest_param(func, *args, capabilities_table=...):
    """Variant of ``make_xp_test_case`` that returns a pytest.param for a function,
    with all necessary skip_xp_backends and xfail_xp_backends marks applied::
    
        @pytest.mark.parametrize(
            "func", [make_xp_pytest_param(f1), make_xp_pytest_param(f2)]
        )
        def test(func, xp):
            ...

    The above is equivalent to::

        @pytest.mark.parametrize(
            "func", [
                pytest.param(f1, marks=[
                    pytest.mark.skip_xp_backends(...),
                    pytest.mark.xfail_xp_backends(...), ...]),
                pytest.param(f2, marks=[
                    pytest.mark.skip_xp_backends(...),
                    pytest.mark.xfail_xp_backends(...), ...]),
        )
        def test(func, xp):
            ...

    Parameters
    ----------
    func : Callable
        Function to be tested. It must be decorated with ``@xp_capabilities``.
    *args : Any, optional
        Extra pytest parameters for the use case, e.g.::

        @pytest.mark.parametrize("func,verb", [
            make_xp_pytest_param(f1, "hello"),
            make_xp_pytest_param(f2, "world")])
        def test(func, verb, xp):
            # iterates on (func=f1, verb="hello")
            # and (func=f2, verb="world")

    See Also
    --------
    xp_capabilities
    make_xp_test_case
    array_api_extra.testing.lazy_xp_function
    """
    ...

xp_capabilities_table = ...
